#!/usr/bin/env python
# CREATED:2013-03-08 15:25:18 by Brian McFee <brm2132@columbia.edu>
#  unit tests for minispec.filters
#
# This test suite verifies that minispec core routines match (numerically) the output
# of various DPWE matlab implementations on a broad range of input parameters.
#
# All test data is generated by the Matlab script "makeTestData.m".
# Each test loads in a .mat file which contains the input and desired output for a given
# function.  The test then runs the minispec implementation and verifies the results
# against the desired output, typically via numpy.allclose().
#

# Disable cache
import os
try:
    os.environ.pop('MINISPEC_CACHE_DIR')
except KeyError:
    pass

import glob
import numpy as np
import scipy.io

import pytest

import minispec


# -- utilities --#
def files(pattern):
    test_files = glob.glob(pattern)
    test_files.sort()
    return test_files


def load(infile):
    DATA = scipy.io.loadmat(infile, chars_as_strings=True)
    return DATA
# --           --#


# -- Tests     --#
def test_hz_to_mel():
    def __test_to_mel(infile):
        DATA = load(infile)
        z = minispec.hz_to_mel(DATA['f'], DATA['htk'])

        assert np.allclose(z, DATA['result'])

    for infile in files(os.path.join('tests', 'data', 'feature-hz_to_mel-*.mat')):
        yield (__test_to_mel, infile)

    pass


def test_mel_to_hz():

    def __test_to_hz(infile):
        DATA = load(infile)
        z = minispec.mel_to_hz(DATA['f'], DATA['htk'])

        assert np.allclose(z, DATA['result'])

    for infile in files(os.path.join('tests', 'data', 'feature-mel_to_hz-*.mat')):
        yield (__test_to_hz, infile)

    pass


def test_melfb():

    def __test_default_norm(infile):
        DATA = load(infile)

        wts = minispec.filters.mel(DATA['sr'][0, 0],
                                  DATA['nfft'][0, 0],
                                  n_mels=DATA['nfilts'][0, 0],
                                  fmin=DATA['fmin'][0, 0],
                                  fmax=DATA['fmax'][0, 0],
                                  htk=DATA['htk'][0, 0])

        # Our version only returns the real-valued part.
        # Pad out.
        wts = np.pad(wts, [(0, 0),
                           (0, int(DATA['nfft'][0]//2 - 1))],
                     mode='constant')

        assert wts.shape == DATA['wts'].shape
        assert np.allclose(wts, DATA['wts'])

    for infile in files(os.path.join('tests', 'data', 'feature-melfb-*.mat')):
        yield (__test_default_norm, infile)

    def __test_with_norm(infile):
        DATA = load(infile)
        # if DATA['norm'] is empty, pass None.
        if DATA['norm'].shape[-1] == 0:
            norm = None
        else:
            norm = DATA['norm'][0, 0]
        wts = minispec.filters.mel(DATA['sr'][0, 0],
                                  DATA['nfft'][0, 0],
                                  n_mels=DATA['nfilts'][0, 0],
                                  fmin=DATA['fmin'][0, 0],
                                  fmax=DATA['fmax'][0, 0],
                                  htk=DATA['htk'][0, 0],
                                  norm=norm)
        # Pad out.
        wts = np.pad(wts, [(0, 0),
                           (0, int(DATA['nfft'][0]//2 - 1))],
                     mode='constant')

        assert wts.shape == DATA['wts'].shape
        assert np.allclose(wts, DATA['wts'])

    for infile in files(os.path.join('tests', 'data', 'feature-melfbnorm-*.mat')):
        yield (__test_with_norm, infile)


def test_mel_gap():

    # This configuration should trigger some empty filters
    sr = 44100
    n_fft = 1024
    fmin = 0
    fmax = 2000
    n_mels = 128
    htk = True

    with pytest.warns(UserWarning, match='Empty filters'):
        minispec.filters.mel(sr, n_fft, n_mels=n_mels,
                            fmin=fmin, fmax=fmax, htk=htk)


def test__window():

    def __test(n, window):

        wdec = minispec.filters.__float_window(window)

        if n == int(n):
            n = int(n)
            assert np.allclose(wdec(n), window(n))
        else:
            wf = wdec(n)
            fn = int(np.floor(n))
            assert not np.any(wf[fn:])

    for n in [16, 16.0, 16.25, 16.75]:
        for window_name in ['barthann', 'bartlett', 'blackman',
                            'blackmanharris', 'bohman', 'boxcar', 'cosine',
                            'flattop', 'hamming', 'hann', 'hanning',
                            'nuttall', 'parzen', 'triang']:
            window = getattr(scipy.signal.windows, window_name)
            yield __test, n, window


@pytest.mark.xfail(raises=minispec.ParameterError)
def test_get_window_fail():

    minispec.filters.get_window(None, 32)


def test_get_window():

    def __test(window):

        w1 = minispec.filters.get_window(window, 32)
        w2 = scipy.signal.get_window(window, 32)

        assert np.allclose(w1, w2)

    for window in ['hann', u'hann', 4.0, ('kaiser', 4.0)]:
        yield __test, window


def test_get_window_func():

    w1 = minispec.filters.get_window(scipy.signal.boxcar, 32)
    w2 = scipy.signal.get_window('boxcar', 32)
    assert np.allclose(w1, w2)


def test_get_window_pre():
    def __test(pre_win):
        win = minispec.filters.get_window(pre_win, len(pre_win))
        assert np.allclose(win, pre_win)

    yield __test, scipy.signal.hann(16)
    yield __test, list(scipy.signal.hann(16))
    yield __test, [1, 1, 1]

